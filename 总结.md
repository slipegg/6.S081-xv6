# Lab: page tables 总结

## Speed up system calls (easy)

### 问题描述

通过在用户空间和内核之间的只读区域中共享数据来加速某些系统调用，以消除执行这些系统调用时对内核交叉的需要。

在创建每个进程时，在 USYSCALL 映射一个只读页面（在memlayout.h中定义的虚拟地址）。在此页面的开头，存储一个struct usyscall （也在memlayout.h中定义），并对其进行初始化以存储当前进程的 PID。对于本实验，已在用户空间端提供ugetpid()并将自动使用 USYSCALL 映射，如下：

```C
#ifdef LAB_PGTBL
int
ugetpid(void)
{
  struct usyscall *u = (struct usyscall *)USYSCALL;
  return u->pid;
}
#endif
```

```C
#ifdef LAB_PGTBL
#define USYSCALL (TRAPFRAME - PGSIZE)

struct usyscall {
  int pid;  // Process ID
};
#endif
```

一些提示：

* 您可以在kernel/proc.c的proc_pagetable()中执行映射。
* 选择允许用户空间仅读取页面的权限位。
* 您可能会发现mappages()是一个有用的实用程序。
* 不要忘记在allocproc()中分配和初始化页面。
* 确保在freeproc()中释放页面。

### 解法

这里主要需要将USYSCALL这个虚拟地址映射到一个物理地址上面去，然后这个物理地址中存储一个struct usyscall。

1. 在proc.h中添加一个`struct usyscall *usyscall;`，用来实际操作usyscall。
2. 在proc.c的 allocproc() 中为usyscall分配一个物理页面，并强制转化为(struct usyscall *)。
    ```C
    // allocate a speed up syscall page
    if ((p->usyscall = (struct usyscall *)kalloc()) == 0) {
        freeproc(p);
        release(&p->lock);
        return 0;
    }
    ```
3. 在proc.c的 proc_pagetable() 中添加USYSCALL和p->usyscall之间的映射：
    ```C
    if (mappages(pagetable, USYSCALL, PGSIZE, 
              (uint64)(p->usyscall), PTE_R | PTE_U) < 0) {
      uvmunmap(pagetable, TRAMPOLINE, 1, 0);
      uvmunmap(pagetable, TRAPFRAME, 1, 0);
      uvmfree(pagetable, 0);
      return 0;
    }
    ```
4. 在释放的空间的时候也需要将映射取消并将物理内存释放，主要是在proc_freepagetable()和freeproc()中。

    ```C
    uvmunmap(pagetable, USYSCALL, 1, 0);
    ```

    ```C
    if (p->usyscall) kfree((void *)p->usyscall);
    p->usyscall = 0;
    ```
