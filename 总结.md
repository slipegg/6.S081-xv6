# Lab: page tables 总结

## Speed up system calls (easy)

### 问题描述

通过在用户空间和内核之间的只读区域中共享数据来加速某些系统调用，以消除执行这些系统调用时对内核交叉的需要。

在创建每个进程时，在 USYSCALL 映射一个只读页面（在memlayout.h中定义的虚拟地址）。在此页面的开头，存储一个struct usyscall （也在memlayout.h中定义），并对其进行初始化以存储当前进程的 PID。对于本实验，已在用户空间端提供ugetpid()并将自动使用 USYSCALL 映射，如下：

```C
#ifdef LAB_PGTBL
int
ugetpid(void)
{
  struct usyscall *u = (struct usyscall *)USYSCALL;
  return u->pid;
}
#endif
```

```C
#ifdef LAB_PGTBL
#define USYSCALL (TRAPFRAME - PGSIZE)

struct usyscall {
  int pid;  // Process ID
};
#endif
```

一些提示：

* 您可以在kernel/proc.c的proc_pagetable()中执行映射。
* 选择允许用户空间仅读取页面的权限位。
* 您可能会发现mappages()是一个有用的实用程序。
* 不要忘记在allocproc()中分配和初始化页面。
* 确保在freeproc()中释放页面。

### 解法

这里主要需要将USYSCALL这个虚拟地址映射到一个物理地址上面去，然后这个物理地址中存储一个struct usyscall。

1. 在proc.h中添加一个`struct usyscall *usyscall;`，用来实际操作usyscall。
2. 在proc.c的 allocproc() 中为usyscall分配一个物理页面，并强制转化为(struct usyscall *)。
    ```C
    // allocate a speed up syscall page
    if ((p->usyscall = (struct usyscall *)kalloc()) == 0) {
        freeproc(p);
        release(&p->lock);
        return 0;
    }
    ```
3. 在proc.c的 proc_pagetable() 中添加USYSCALL和p->usyscall之间的映射：
    ```C
    if (mappages(pagetable, USYSCALL, PGSIZE, 
              (uint64)(p->usyscall), PTE_R | PTE_U) < 0) {
      uvmunmap(pagetable, TRAMPOLINE, 1, 0);
      uvmunmap(pagetable, TRAPFRAME, 1, 0);
      uvmfree(pagetable, 0);
      return 0;
    }
    ```
4. 在释放的空间的时候也需要将映射取消并将物理内存释放，主要是在proc_freepagetable()和freeproc()中。

    ```C
    uvmunmap(pagetable, USYSCALL, 1, 0);
    ```

    ```C
    if (p->usyscall) kfree((void *)p->usyscall);
    p->usyscall = 0;
    ```

## Print a page table (easy)

### 问题描述

定义一个名为vmprint() 的函数。它应该采用pagetable_t参数，并以下面描述的格式打印该页表。在 exec.c 中的return argc之前插入if(p->pid==1) vmprint(p->pagetable)，以打印第一个进程的页表。

现在，当您启动 xv6 时，它应该像这样打印输出，描述第一个进程在它刚刚完成exec() ing init时的页表：

```
page table 0x0000000087f6e000
 ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000
 .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000
 .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000
 .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000
 .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000
 ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000
 .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000
 .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000
 .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000
 .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000
```

第一行显示 vmprint 的参数。之后每个 PTE 都有一行，包括引用树中较深的页表页的 PTE。每个 PTE 行都缩进了一些“..”，表示它在树中的深度。每个 PTE 行显示其页表页中的 PTE 索引、pte 位和从 PTE 中提取的物理地址。不要打印无效的 PTE。在上面的示例中，顶层页表页具有条目 0 和 255 的映射。条目 0 的下一层仅映射索引 0，索引 0 的底层具有条目 0、1 和2 映射。
您的代码可能会发出与上面显示的不同的物理地址。条目数和虚拟地址应该相同。

一些提示：

* 您可以将vmprint()放在kernel/vm.c中。
* 使用文件 kernel/riscv.h 末尾的宏。
* 功能freewalk可能会鼓舞人心。
* 在 kernel/defs.h 中定义vmprint的原型，以便您可以从 exec.c 中调用它。
* 在 printf 调用中使用%p打印出完整的 64 位十六进制 PTE 和地址，如示例所示。

### 解法

主要就是完成vmprint这个函数，在页表中查找合法的pte，然后递归查找，递归两层，查找完就打印。主要步骤如下：

1. 在exec.c中的exec函数加入`if(p->pid==1) vmprint(p->pagetable);`
2. 在defs.h中加入vmprint的定义：`void            vmprint(pagetable_t);`
3. 在vm.c中加入vmprintlevel的实现。
    ```C
    void vmprintlevel(pagetable_t pt, int level) {
      char *delim = 0;
      if (level == 2) delim = "..";
      if (level == 1) delim = ".. ..";
      if (level == 0) delim = ".. .. ..";
      for (int i = 0; i < 512; i++) {
          pte_t pte = pt[i];
          if ((pte & PTE_V)) {
              //  this PTE points to a lower level page table.
              printf("%s%d: pte %p pa %p\n", delim, i, pte, PTE2PA(pte));
              uint64 child = PTE2PA(pte);
              if (level != 0) {
                  vmprintlevel((pagetable_t)child, level - 1);
              }
          }
      }
    }

    void vmprint(pagetable_t pt) {
      printf("page table %p\n", pt);
      vmprintlevel(pt, 2);
    }
    ```
