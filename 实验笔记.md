# Lab: system calls实验笔记

## System call tracing

在完成之前需要先查看前面关于gdb的介绍，然后跟着教授的介绍上手去使用gdb，以查看系统是如何进行初始化的，以及内核的一些操作是如何实现的，对于这个作业重点需要关注syscall，需要使用gdb对其进行运行查看，搞懂围绕着它进行的一系列操作。

下面介绍一下自己对于这个作业整个过程的理解。

0. 在MAKEFILE中加入 $U/_trace。
1. 对于用户其系统的声明在`user/user.h`，所以需要将`int trace(int);`加入其中。
2. 对于系统调用的实现是通过`user/usys.pl`来将用户的系统调用的参数存入到栈中，并将系统调用的调用号存在`a7`中，然后使用ecall转入到内核态，执行系统调用。
3. 内核处理系统调用是在`kernel/syscall.c:syscall`中，它会读取进程的`proc->trapframe->a7`——一个数字，来决定运行函数数组中的哪个系统调用。所以需要把SYS_trace加入到`SYS_trace`中，然后在`kernel/syscall.c`中把sys_trace加到函数数组中。
4. 然后需要在`kernel/sysproc.c`中实现sys_trace，它需要读取参数`proc->trapframe->a0`然后将其放入到proc->trace_mask中。所以也还需要在`kernel/proc.h`中修改sysproc的定义，加入`int trace_mask;`
5. 然后实现每次系统调用的时候查看掩码，已决定是否需要输出提示。也是加在`kernel/syscall.c:syscall`中，每次系统调用结束后，获取返回值然后判断掩码以决定是否打印提示信息，如下：
    ```C
    p->trapframe->a0 = syscalls[num]();
    // 打印追踪信息
    if ((1 << num) & (p->trace_mask))
      printf("%d: syscall %s -> %d\n", p->pid, syscallname[num], p->trapframe->a0);
    ```
    注意这里的掩码判断用的很经典：num是第几个系统调用，trace_mask是已经右移过的，在输入时给的参数。
6. 额外的还需要修改`kernel/proc.c:fork`，使得子进程也复制父进程的trace_mask。

## Sysinfo

大体的流程和上一个基本相同，如下：

0. 添加 $U/_sysinfotest到Makefile
1. 在`user/user.h`,`user/usys.pl`,`kernel/syscall.c`,`kernel/proc.h`添加sysinfo的内容
2. 实现对freemem和nproc的统计函数
    * freemem在`kernel/kalloc.c`中，主要是遍历kmem.freelist链表，累加得到空闲空间，
    * nproc在`kernel/proc.c`中，遍历proc，统计state != UNUSED的数量
3. 实现sysinfo，代码如下：
    ```C
    uint64
    sys_sysinfo(void)
    {
    struct sysinfo info;
    freebytes(&(info.freemem));
    procnum(&(info.nproc));
    // 获取虚拟地址
    uint64 destaddr;
    argaddr(0, &destaddr);

    // 从kernel拷贝到user
    if (copyout(myproc()->pagetable, destaddr, (char *)&info, sizeof info) < 0)
        return -1;
    return 0;
    }
    ```
    需要注意copyout的用法，他是一个负责将内核的数据拷贝到用户态的函数，使用方法需要明晰。